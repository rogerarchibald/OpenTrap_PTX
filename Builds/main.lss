
Builds/main.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000000e  00800100  00000806  0000089a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000806  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000010  0080010e  0080010e  000008a8  2**0
                  ALLOC
  3 .stab         00002784  00000000  00000000  000008a8  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00001b59  00000000  00000000  0000302c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  00004b85  2**0
                  CONTENTS, READONLY
  6 .debug_info   000005f4  00000000  00000000  00004b96  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000005a2  00000000  00000000  0000518a  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000001d  00000000  00000000  0000572c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000208  00000000  00000000  00005749  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
   4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  1c:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__vector_7>
  20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  2c:	0c 94 84 03 	jmp	0x708	; 0x708 <__vector_11>
  30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  40:	0c 94 b2 02 	jmp	0x564	; 0x564 <__vector_16>
  44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  48:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
  68:	11 24       	eor	r1, r1
  6a:	1f be       	out	0x3f, r1	; 63
  6c:	cf ef       	ldi	r28, 0xFF	; 255
  6e:	d8 e0       	ldi	r29, 0x08	; 8
  70:	de bf       	out	0x3e, r29	; 62
  72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
  74:	11 e0       	ldi	r17, 0x01	; 1
  76:	a0 e0       	ldi	r26, 0x00	; 0
  78:	b1 e0       	ldi	r27, 0x01	; 1
  7a:	e6 e0       	ldi	r30, 0x06	; 6
  7c:	f8 e0       	ldi	r31, 0x08	; 8
  7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
  80:	05 90       	lpm	r0, Z+
  82:	0d 92       	st	X+, r0
  84:	ae 30       	cpi	r26, 0x0E	; 14
  86:	b1 07       	cpc	r27, r17
  88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
  8a:	11 e0       	ldi	r17, 0x01	; 1
  8c:	ae e0       	ldi	r26, 0x0E	; 14
  8e:	b1 e0       	ldi	r27, 0x01	; 1
  90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
  92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
  94:	ae 31       	cpi	r26, 0x1E	; 30
  96:	b1 07       	cpc	r27, r17
  98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
  9a:	0e 94 c3 03 	call	0x786	; 0x786 <main>
  9e:	0c 94 01 04 	jmp	0x802	; 0x802 <_exit>

000000a2 <__bad_interrupt>:
  a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <ADC_Init>:

#include "ADC.h"

void ADC_Init(void) {
	
	ADMUX = 0x67;	// 6 is selecting Left Allign and reference voltage. LSNibble == 7 is for ADC7
  a6:	87 e6       	ldi	r24, 0x67	; 103
  a8:	80 93 7c 00 	sts	0x007C, r24
	ADCSRA = 0x95;	//Enable ADC, write a 1 to the interrupt flag to clear it, and set prescaler to 32.  
  ac:	85 e9       	ldi	r24, 0x95	; 149
  ae:	80 93 7a 00 	sts	0x007A, r24
  b2:	08 95       	ret

000000b4 <checkADC_Stat>:
}

//This will deterimine if an ADC conversion has been completed
u8 checkADC_Stat(void){
	if(ADCSRA & 0x10){
  b4:	80 91 7a 00 	lds	r24, 0x007A
		return 1;
	}else{
		return 0;
	}
	
}
  b8:	82 95       	swap	r24
  ba:	81 70       	andi	r24, 0x01	; 1
  bc:	08 95       	ret

000000be <start_ADC_conv>:

//initialize ADC conversion
void start_ADC_conv (void){
	ADCSRA |= 0x40;	//ADC Start Conversion
  be:	ea e7       	ldi	r30, 0x7A	; 122
  c0:	f0 e0       	ldi	r31, 0x00	; 0
  c2:	80 81       	ld	r24, Z
  c4:	80 64       	ori	r24, 0x40	; 64
  c6:	80 83       	st	Z, r24
  c8:	08 95       	ret

000000ca <readADC>:


//For right now this is returning the left-alligned (upper 8 bits of the 10-bit ADC) 8-bit conversion.  Might just have this return 1 or zero depending on whether or not the value is above my minimum VCC threshold.
u8 readADC(void){

	ADCSRA |= 0x10;	//clear interrupt flag
  ca:	80 91 7a 00 	lds	r24, 0x007A
  ce:	80 61       	ori	r24, 0x10	; 16
  d0:	80 93 7a 00 	sts	0x007A, r24
	if(ADCH > 170){	//170 ~= 6.8V, if I'm above there then I should be good
  d4:	90 91 79 00 	lds	r25, 0x0079
  d8:	81 e0       	ldi	r24, 0x01	; 1
  da:	9b 3a       	cpi	r25, 0xAB	; 171
  dc:	08 f0       	brcs	.+2      	; 0xe0 <readADC+0x16>
  de:	80 e0       	ldi	r24, 0x00	; 0
		return 0;
	}
	return 1;	//TODO modify this function to compare read value to a low-battery threshold and set flag accordingly
	//return ADCH;
	}
  e0:	08 95       	ret

000000e2 <enable_PRX>:
static u8 CFGValues = 0x7C;	//7C where I'm going to start this.  Two things that will be tweaked are: Bit0 which determines if we're PTX or PRX, this is determined in 'main.c'.  Also bit 1 is the powerup, have functions called PowerUp and PowerDn to control this.
u8 Addy [] = {0x52, 0x6F, 0x67, 0x65, 0x72}; //Believe that as long as we're looking at only one TX/RX combo than only need one address

//this will only be called just prior to initializing the NRF in case 'PRF' has been defined in Main.
void enable_PRX (void){
CFGValues |= 0x01;
  e2:	80 91 07 01 	lds	r24, 0x0107
  e6:	81 60       	ori	r24, 0x01	; 1
  e8:	80 93 07 01 	sts	0x0107, r24
  ec:	08 95       	ret

000000ee <sendbyte>:
}


//This is the lowest level function which requires something above it to enable the CSN line.  It just writes a byte to the SPI data register and waits until it's been clocked through
void sendbyte (u8 sendit){
    SPDR = sendit;                  //write 'sendit' to the data register.
  ee:	8e bd       	out	0x2e, r24	; 46
    while(!(SPSR & (1<<SPIF) ));    //wait for transmission to complete.
  f0:	0d b4       	in	r0, 0x2d	; 45
  f2:	07 fe       	sbrs	r0, 7
  f4:	fd cf       	rjmp	.-6      	; 0xf0 <sendbyte+0x2>
}
  f6:	08 95       	ret

000000f8 <sendcmd>:

//Sending a single byte and not requiring a response.  sendbyte is a sub-function
void sendcmd (u8 byteout){
    clr_csn;
  f8:	5f 98       	cbi	0x0b, 7	; 11
    sendbyte(byteout);
  fa:	0e 94 77 00 	call	0xee	; 0xee <sendbyte>
    set_csn;
  fe:	5f 9a       	sbi	0x0b, 7	; 11
 100:	08 95       	ret

00000102 <readRXWidth>:
}

u8 readRXWidth(void){
	clr_csn;
 102:	5f 98       	cbi	0x0b, 7	; 11
	sendbyte(R_RX_PL_WID);	//command to read the payload width
 104:	80 e6       	ldi	r24, 0x60	; 96
 106:	0e 94 77 00 	call	0xee	; 0xee <sendbyte>
	sendbyte(0x55);			//dummy byte while clocking out pl width
 10a:	85 e5       	ldi	r24, 0x55	; 85
 10c:	0e 94 77 00 	call	0xee	; 0xee <sendbyte>
	set_csn;
 110:	5f 9a       	sbi	0x0b, 7	; 11
	return	SPDR;		//return RX Width
 112:	8e b5       	in	r24, 0x2e	; 46
}
 114:	08 95       	ret

00000116 <flushTx>:


void flushTx(void){
	sendcmd(FLUSH_TX);
 116:	81 ee       	ldi	r24, 0xE1	; 225
 118:	0c 94 7c 00 	jmp	0xf8	; 0xf8 <sendcmd>

0000011c <flushRx>:
}

void flushRx(void){
	sendcmd(FLUSH_RX);
 11c:	82 ee       	ldi	r24, 0xE2	; 226
 11e:	0c 94 7c 00 	jmp	0xf8	; 0xf8 <sendcmd>

00000122 <readStatus>:
}

//Read the STATUS register which is clocked out as the first byte of any SPI transfer is clocked in.  This is accomplished here by sending the 'NOP' (0xFF) command to the NRF
u8 readStatus (void){
    clr_csn;
 122:	5f 98       	cbi	0x0b, 7	; 11
    sendbyte(0xff); //probably want to define this as 'nop' in NRF-specific Library file
 124:	8f ef       	ldi	r24, 0xFF	; 255
 126:	0e 94 77 00 	call	0xee	; 0xee <sendbyte>
    set_csn;
 12a:	5f 9a       	sbi	0x0b, 7	; 11
    return SPDR;
 12c:	8e b5       	in	r24, 0x2e	; 46
}
 12e:	08 95       	ret

00000130 <readReg>:


/*Function below here will Read registers where 'Register' is the 5-bit address of the register which is defined in another library.  'destination' is a pointer to where these will go and size is the number of bytes that need to be read from that register. */

void readReg(u8 Register, u8 * destination, u8 size){
 130:	ef 92       	push	r14
 132:	ff 92       	push	r15
 134:	0f 93       	push	r16
 136:	1f 93       	push	r17
 138:	cf 93       	push	r28
 13a:	df 93       	push	r29
 13c:	8b 01       	movw	r16, r22
 13e:	f4 2e       	mov	r15, r20
clr_csn;
 140:	5f 98       	cbi	0x0b, 7	; 11
sendbyte (Register); //write the adress of the register we're writing to.
 142:	0e 94 77 00 	call	0xee	; 0xee <sendbyte>
    if (1==size) {
 146:	81 e0       	ldi	r24, 0x01	; 1
 148:	f8 16       	cp	r15, r24
 14a:	21 f0       	breq	.+8      	; 0x154 <readReg+0x24>
 14c:	e0 2e       	mov	r14, r16
 14e:	c0 2f       	mov	r28, r16
 150:	d1 2f       	mov	r29, r17
 152:	07 c0       	rjmp	.+14     	; 0x162 <readReg+0x32>
        sendbyte(0x55);		//55 is a dummy byte just to clock something out
 154:	85 e5       	ldi	r24, 0x55	; 85
 156:	0e 94 77 00 	call	0xee	; 0xee <sendbyte>
       *destination = SPDR;
 15a:	8e b5       	in	r24, 0x2e	; 46
 15c:	f8 01       	movw	r30, r16
 15e:	80 83       	st	Z, r24
        goto regreadbail;            //if it's only a single-byte read then read the reg and bail.
 160:	0a c0       	rjmp	.+20     	; 0x176 <readReg+0x46>
 162:	8c 2f       	mov	r24, r28
 164:	8e 19       	sub	r24, r14
    }
    for (u8 i = 0; i < size; i++){
 166:	8f 15       	cp	r24, r15
 168:	30 f4       	brcc	.+12     	; 0x176 <readReg+0x46>
        sendbyte(0x55);
 16a:	85 e5       	ldi	r24, 0x55	; 85
 16c:	0e 94 77 00 	call	0xee	; 0xee <sendbyte>
    destination[i] = SPDR;
 170:	8e b5       	in	r24, 0x2e	; 46
 172:	89 93       	st	Y+, r24
 174:	f6 cf       	rjmp	.-20     	; 0x162 <readReg+0x32>
}
regreadbail:    //if it's a single-byte read then come here after reading it.
set_csn;
 176:	5f 9a       	sbi	0x0b, 7	; 11
}
 178:	df 91       	pop	r29
 17a:	cf 91       	pop	r28
 17c:	1f 91       	pop	r17
 17e:	0f 91       	pop	r16
 180:	ff 90       	pop	r15
 182:	ef 90       	pop	r14
 184:	08 95       	ret

00000186 <writeRegMult>:



/*    Here Register is the 5-bit address of the register which is defined in other library, but in this case it will need to be ORâ€™d with 0x20 to make it the write command.*/

void writeRegMult(u8 Register, u8 * source, u8 size){
 186:	ef 92       	push	r14
 188:	ff 92       	push	r15
 18a:	0f 93       	push	r16
 18c:	1f 93       	push	r17
 18e:	cf 93       	push	r28
 190:	df 93       	push	r29
 192:	00 d0       	rcall	.+0      	; 0x194 <writeRegMult+0xe>
 194:	cd b7       	in	r28, 0x3d	; 61
 196:	de b7       	in	r29, 0x3e	; 62
 198:	14 2f       	mov	r17, r20
clr_csn;
 19a:	5f 98       	cbi	0x0b, 7	; 11
sendbyte((Register | 0x20));
 19c:	80 62       	ori	r24, 0x20	; 32
 19e:	69 83       	std	Y+1, r22	; 0x01
 1a0:	7a 83       	std	Y+2, r23	; 0x02
 1a2:	0e 94 77 00 	call	0xee	; 0xee <sendbyte>
 1a6:	69 81       	ldd	r22, Y+1	; 0x01
 1a8:	06 2f       	mov	r16, r22
    for (u8 i = 0; i < size; i++){
 1aa:	e6 2e       	mov	r14, r22
 1ac:	7a 81       	ldd	r23, Y+2	; 0x02
 1ae:	f7 2e       	mov	r15, r23
 1b0:	8e 2d       	mov	r24, r14
 1b2:	80 1b       	sub	r24, r16
 1b4:	81 17       	cp	r24, r17
 1b6:	30 f4       	brcc	.+12     	; 0x1c4 <writeRegMult+0x3e>
        sendbyte(source[i]);
 1b8:	f7 01       	movw	r30, r14
 1ba:	81 91       	ld	r24, Z+
 1bc:	7f 01       	movw	r14, r30
 1be:	0e 94 77 00 	call	0xee	; 0xee <sendbyte>
 1c2:	f6 cf       	rjmp	.-20     	; 0x1b0 <writeRegMult+0x2a>
    }
    set_csn;
 1c4:	5f 9a       	sbi	0x0b, 7	; 11
}
 1c6:	0f 90       	pop	r0
 1c8:	0f 90       	pop	r0
 1ca:	df 91       	pop	r29
 1cc:	cf 91       	pop	r28
 1ce:	1f 91       	pop	r17
 1d0:	0f 91       	pop	r16
 1d2:	ff 90       	pop	r15
 1d4:	ef 90       	pop	r14
 1d6:	08 95       	ret

000001d8 <writeRegSing>:


void writeRegSing(u8 Register, u8 data){
 1d8:	cf 93       	push	r28
 1da:	df 93       	push	r29
 1dc:	1f 92       	push	r1
 1de:	cd b7       	in	r28, 0x3d	; 61
 1e0:	de b7       	in	r29, 0x3e	; 62
	clr_csn;
 1e2:	5f 98       	cbi	0x0b, 7	; 11
	sendbyte((Register | 0x20));	//'OR register address with 0x20 to indicate it's a write command
 1e4:	80 62       	ori	r24, 0x20	; 32
 1e6:	69 83       	std	Y+1, r22	; 0x01
 1e8:	0e 94 77 00 	call	0xee	; 0xee <sendbyte>
	sendbyte(data);
 1ec:	69 81       	ldd	r22, Y+1	; 0x01
 1ee:	86 2f       	mov	r24, r22
 1f0:	0e 94 77 00 	call	0xee	; 0xee <sendbyte>
	set_csn;
 1f4:	5f 9a       	sbi	0x0b, 7	; 11
}
 1f6:	0f 90       	pop	r0
 1f8:	df 91       	pop	r29
 1fa:	cf 91       	pop	r28
 1fc:	08 95       	ret

000001fe <check_Flag>:



//Check and Clear specific flags in the Status Register for RX_DR, TX_DS, and MAX_RT

u8	check_Flag (u8 flag){
 1fe:	cf 93       	push	r28
 200:	c8 2f       	mov	r28, r24
u8	temp = readStatus();
 202:	0e 94 91 00 	call	0x122	; 0x122 <readStatus>
if (temp & flag){
 206:	c8 23       	and	r28, r24
 208:	81 e0       	ldi	r24, 0x01	; 1
 20a:	09 f4       	brne	.+2      	; 0x20e <check_Flag+0x10>
 20c:	80 e0       	ldi	r24, 0x00	; 0
	return 1;
}else{
	return 0;
	}
}
 20e:	cf 91       	pop	r28
 210:	08 95       	ret

00000212 <clear_Flag>:

void clear_Flag	(u8 flag){
 212:	cf 93       	push	r28
 214:	df 93       	push	r29
 216:	1f 92       	push	r1
 218:	cd b7       	in	r28, 0x3d	; 61
 21a:	de b7       	in	r29, 0x3e	; 62
u8 temp = readStatus();
 21c:	89 83       	std	Y+1, r24	; 0x01
 21e:	0e 94 91 00 	call	0x122	; 0x122 <readStatus>
temp |= flag;
writeRegSing(STATUS,flag);	
 222:	69 81       	ldd	r22, Y+1	; 0x01
 224:	87 e0       	ldi	r24, 0x07	; 7
}
 226:	0f 90       	pop	r0
 228:	df 91       	pop	r29
 22a:	cf 91       	pop	r28
}

void clear_Flag	(u8 flag){
u8 temp = readStatus();
temp |= flag;
writeRegSing(STATUS,flag);	
 22c:	0c 94 ec 00 	jmp	0x1d8	; 0x1d8 <writeRegSing>

00000230 <receivePayLoad>:
ten_uS_ce_Pulse();	//10uS pulse on Chip Enable to make it transmit.  Will probably work this into Timers later on. 
}
}


void receivePayLoad(u8 * payload_dest, u8 size){
 230:	ef 92       	push	r14
 232:	ff 92       	push	r15
 234:	0f 93       	push	r16
 236:	1f 93       	push	r17
 238:	cf 93       	push	r28
 23a:	df 93       	push	r29
 23c:	7c 01       	movw	r14, r24
 23e:	c6 2f       	mov	r28, r22
	clr_csn;
 240:	5f 98       	cbi	0x0b, 7	; 11
	sendbyte(R_RX_PAYLOAD);	//command to receive paylaod
 242:	81 e6       	ldi	r24, 0x61	; 97
 244:	0e 94 77 00 	call	0xee	; 0xee <sendbyte>
	for(int i =0; i < size; i ++){
 248:	87 01       	movw	r16, r14
 24a:	d0 e0       	ldi	r29, 0x00	; 0
 24c:	c8 01       	movw	r24, r16
 24e:	8e 19       	sub	r24, r14
 250:	9f 09       	sbc	r25, r15
 252:	8c 17       	cp	r24, r28
 254:	9d 07       	cpc	r25, r29
 256:	44 f4       	brge	.+16     	; 0x268 <receivePayLoad+0x38>
		sendbyte(0x55);	//dummy byte just to send something
 258:	85 e5       	ldi	r24, 0x55	; 85
 25a:	0e 94 77 00 	call	0xee	; 0xee <sendbyte>
		payload_dest[i] = SPDR;
 25e:	8e b5       	in	r24, 0x2e	; 46
 260:	f8 01       	movw	r30, r16
 262:	81 93       	st	Z+, r24
 264:	8f 01       	movw	r16, r30
 266:	f2 cf       	rjmp	.-28     	; 0x24c <receivePayLoad+0x1c>
	}
	set_csn;
 268:	5f 9a       	sbi	0x0b, 7	; 11
}
 26a:	df 91       	pop	r29
 26c:	cf 91       	pop	r28
 26e:	1f 91       	pop	r17
 270:	0f 91       	pop	r16
 272:	ff 90       	pop	r15
 274:	ef 90       	pop	r14
 276:	08 95       	ret

00000278 <get_RX_Data>:



u8 get_RX_Data(u8 *destination){
 278:	cf 93       	push	r28
 27a:	df 93       	push	r29
 27c:	ec 01       	movw	r28, r24
	u8 width = readRXWidth();
 27e:	0e 94 81 00 	call	0x102	; 0x102 <readRXWidth>
	//TODO: If Width is above 32(MAX FOR CHIP) or above whatever max I set in software, flag an error
	receivePayLoad(destination, width);
 282:	68 2f       	mov	r22, r24
 284:	ce 01       	movw	r24, r28
 286:	0e 94 18 01 	call	0x230	; 0x230 <receivePayLoad>
	flushRx();
 28a:	0e 94 8e 00 	call	0x11c	; 0x11c <flushRx>
	clear_Flag(RX_DR);
 28e:	80 e4       	ldi	r24, 0x40	; 64
 290:	0e 94 09 01 	call	0x212	; 0x212 <clear_Flag>
	return 1;	//will use this as a flag to say that there's fresh data, will kill flag after reading data. 
}
 294:	81 e0       	ldi	r24, 0x01	; 1
 296:	df 91       	pop	r29
 298:	cf 91       	pop	r28
 29a:	08 95       	ret

0000029c <powerUp>:




void powerUp (void){
	CFGValues |= 0x02;
 29c:	60 91 07 01 	lds	r22, 0x0107
 2a0:	62 60       	ori	r22, 0x02	; 2
 2a2:	60 93 07 01 	sts	0x0107, r22
	writeRegSing(CONFIG, CFGValues);
 2a6:	80 e0       	ldi	r24, 0x00	; 0
 2a8:	0e 94 ec 00 	call	0x1d8	; 0x1d8 <writeRegSing>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 2ac:	8f e0       	ldi	r24, 0x0F	; 15
 2ae:	97 e2       	ldi	r25, 0x27	; 39
 2b0:	01 97       	sbiw	r24, 0x01	; 1
 2b2:	f1 f7       	brne	.-4      	; 0x2b0 <powerUp+0x14>
 2b4:	00 c0       	rjmp	.+0      	; 0x2b6 <powerUp+0x1a>
 2b6:	00 00       	nop
 2b8:	08 95       	ret

000002ba <powerDown>:
	_delay_ms(5);	//a bit of a delay for this thing to settle down before trying to send data.
}

void powerDown(void){
	CFGValues &= ~(0x02);
 2ba:	60 91 07 01 	lds	r22, 0x0107
 2be:	6d 7f       	andi	r22, 0xFD	; 253
 2c0:	60 93 07 01 	sts	0x0107, r22
	writeRegSing(CONFIG, CFGValues);
 2c4:	80 e0       	ldi	r24, 0x00	; 0
 2c6:	0c 94 ec 00 	jmp	0x1d8	; 0x1d8 <writeRegSing>

000002ca <ten_uS_ce_Pulse>:
}


void ten_uS_ce_Pulse(void){
	set_ce;
 2ca:	28 9a       	sbi	0x05, 0	; 5
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 2cc:	8d e1       	ldi	r24, 0x1D	; 29
 2ce:	8a 95       	dec	r24
 2d0:	f1 f7       	brne	.-4      	; 0x2ce <ten_uS_ce_Pulse+0x4>
 2d2:	00 00       	nop
	_delay_us(11);	//yeah, it's eleven, just to be safe
	clr_ce;
 2d4:	28 98       	cbi	0x05, 0	; 5
 2d6:	08 95       	ret

000002d8 <sendPayLoad>:


/* following functions are for sending/retrieving payloads from the NRF.  */


void sendPayLoad(u8 TXorAWK, u8 * plsource, u8 size){
 2d8:	cf 92       	push	r12
 2da:	df 92       	push	r13
 2dc:	ff 92       	push	r15
 2de:	0f 93       	push	r16
 2e0:	1f 93       	push	r17
 2e2:	cf 93       	push	r28
 2e4:	df 93       	push	r29
 2e6:	f8 2e       	mov	r15, r24
 2e8:	6b 01       	movw	r12, r22
 2ea:	c4 2f       	mov	r28, r20
flushTx();		//clear the buffer first
 2ec:	0e 94 8b 00 	call	0x116	; 0x116 <flushTx>
clr_csn;
 2f0:	5f 98       	cbi	0x0b, 7	; 11
sendbyte(TXorAWK);		//this will be either the command to W_TX_PAYLOAD (0xA0) or the command to W_ACK_PAYLOAD(0xAX) where nibble X = 1PPP where P = pipe address.
 2f2:	8f 2d       	mov	r24, r15
 2f4:	0e 94 77 00 	call	0xee	; 0xee <sendbyte>
for (int i = 0; i < size; i++){
 2f8:	86 01       	movw	r16, r12
 2fa:	d0 e0       	ldi	r29, 0x00	; 0
 2fc:	c8 01       	movw	r24, r16
 2fe:	8c 19       	sub	r24, r12
 300:	9d 09       	sbc	r25, r13
 302:	8c 17       	cp	r24, r28
 304:	9d 07       	cpc	r25, r29
 306:	34 f4       	brge	.+12     	; 0x314 <sendPayLoad+0x3c>
	sendbyte(plsource[i]);
 308:	f8 01       	movw	r30, r16
 30a:	81 91       	ld	r24, Z+
 30c:	8f 01       	movw	r16, r30
 30e:	0e 94 77 00 	call	0xee	; 0xee <sendbyte>
 312:	f4 cf       	rjmp	.-24     	; 0x2fc <sendPayLoad+0x24>
}
set_csn;
 314:	5f 9a       	sbi	0x0b, 7	; 11
if(TXorAWK == W_TX_PAYLOAD){	//if I'm here because of writing a PTX payload and not an awk-pak payload, pulse CE
 316:	f0 ea       	ldi	r31, 0xA0	; 160
 318:	ff 12       	cpse	r15, r31
 31a:	09 c0       	rjmp	.+18     	; 0x32e <sendPayLoad+0x56>
ten_uS_ce_Pulse();	//10uS pulse on Chip Enable to make it transmit.  Will probably work this into Timers later on. 
}
}
 31c:	df 91       	pop	r29
 31e:	cf 91       	pop	r28
 320:	1f 91       	pop	r17
 322:	0f 91       	pop	r16
 324:	ff 90       	pop	r15
 326:	df 90       	pop	r13
 328:	cf 90       	pop	r12
for (int i = 0; i < size; i++){
	sendbyte(plsource[i]);
}
set_csn;
if(TXorAWK == W_TX_PAYLOAD){	//if I'm here because of writing a PTX payload and not an awk-pak payload, pulse CE
ten_uS_ce_Pulse();	//10uS pulse on Chip Enable to make it transmit.  Will probably work this into Timers later on. 
 32a:	0c 94 65 01 	jmp	0x2ca	; 0x2ca <ten_uS_ce_Pulse>
}
}
 32e:	df 91       	pop	r29
 330:	cf 91       	pop	r28
 332:	1f 91       	pop	r17
 334:	0f 91       	pop	r16
 336:	ff 90       	pop	r15
 338:	df 90       	pop	r13
 33a:	cf 90       	pop	r12
 33c:	08 95       	ret

0000033e <initialize_NRF>:
	clr_ce;
}


void initialize_NRF(void){
set_csn;
 33e:	5f 9a       	sbi	0x0b, 7	; 11
clr_ce;				//clear Chip Enable in case not already done.
 340:	28 98       	cbi	0x05, 0	; 5
writeRegSing(CONFIG, CFGValues);	//initially powered down, CFGValues will be setup for either TX or RX by main depending on whether or not PRX is defined
 342:	60 91 07 01 	lds	r22, 0x0107
 346:	80 e0       	ldi	r24, 0x00	; 0
 348:	0e 94 ec 00 	call	0x1d8	; 0x1d8 <writeRegSing>
writeRegSing(SETUP_RETR, 0x77);	//2mS between retries, 7 total retries
 34c:	67 e7       	ldi	r22, 0x77	; 119
 34e:	84 e0       	ldi	r24, 0x04	; 4
 350:	0e 94 ec 00 	call	0x1d8	; 0x1d8 <writeRegSing>
writeRegSing(RF_SETUP, 0x06);	//1MBPS, zero TX attenuation
 354:	66 e0       	ldi	r22, 0x06	; 6
 356:	86 e0       	ldi	r24, 0x06	; 6
 358:	0e 94 ec 00 	call	0x1d8	; 0x1d8 <writeRegSing>
writeRegMult(RX_ADDR_P0, Addy, 5);
 35c:	45 e0       	ldi	r20, 0x05	; 5
 35e:	62 e0       	ldi	r22, 0x02	; 2
 360:	71 e0       	ldi	r23, 0x01	; 1
 362:	8a e0       	ldi	r24, 0x0A	; 10
 364:	0e 94 c3 00 	call	0x186	; 0x186 <writeRegMult>
writeRegMult(TX_ADDR, Addy, 5);		//Making TX and RX addresses the same
 368:	45 e0       	ldi	r20, 0x05	; 5
 36a:	62 e0       	ldi	r22, 0x02	; 2
 36c:	71 e0       	ldi	r23, 0x01	; 1
 36e:	80 e1       	ldi	r24, 0x10	; 16
 370:	0e 94 c3 00 	call	0x186	; 0x186 <writeRegMult>
writeRegSing(DYNPD, 0x01);	//enable Dynamic Payload for RX Pipe
 374:	61 e0       	ldi	r22, 0x01	; 1
 376:	8c e1       	ldi	r24, 0x1C	; 28
 378:	0e 94 ec 00 	call	0x1d8	; 0x1d8 <writeRegSing>
writeRegSing(FEATURE, 0x06);	//enablying Dynamic Payload Length and Awk-Pac w/Payload
 37c:	66 e0       	ldi	r22, 0x06	; 6
 37e:	8d e1       	ldi	r24, 0x1D	; 29
 380:	0e 94 ec 00 	call	0x1d8	; 0x1d8 <writeRegSing>
clear_Flag(ALL_FLAG);
 384:	80 e7       	ldi	r24, 0x70	; 112
 386:	0e 94 09 01 	call	0x212	; 0x212 <clear_Flag>
flushTx();
 38a:	0e 94 8b 00 	call	0x116	; 0x116 <flushTx>
flushRx();
 38e:	0e 94 8e 00 	call	0x11c	; 0x11c <flushRx>
powerUp();		//will probably only want this in the Receiver once things are squared away.  TX will be powered up to TX data and then powered down in order to conserve battery
 392:	0c 94 4e 01 	jmp	0x29c	; 0x29c <powerUp>

00000396 <fill_TX_bitfield>:





u8 fill_TX_bitfield(void){
 396:	cf 93       	push	r28
	u8 tempval = 0x15;	//0x15 is starting point, not critical
//	tempval |= (checkIR());	//IR_stateval
	tempval |= (readADC() << 6);	//readADC will return a 1 if the battery voltage is below a threshold
 398:	0e 94 65 00 	call	0xca	; 0xca <readADC>
 39c:	c8 2f       	mov	r28, r24
	start_ADC_conv();	//initialize a new conversion for next time
 39e:	0e 94 5f 00 	call	0xbe	; 0xbe <start_ADC_conv>
	tempval |= (chk_trap_status() << 5);	
 3a2:	0e 94 44 03 	call	0x688	; 0x688 <chk_trap_status>


u8 fill_TX_bitfield(void){
	u8 tempval = 0x15;	//0x15 is starting point, not critical
//	tempval |= (checkIR());	//IR_stateval
	tempval |= (readADC() << 6);	//readADC will return a 1 if the battery voltage is below a threshold
 3a6:	40 e4       	ldi	r20, 0x40	; 64
 3a8:	c4 9f       	mul	r28, r20
 3aa:	90 01       	movw	r18, r0
 3ac:	11 24       	eor	r1, r1
	start_ADC_conv();	//initialize a new conversion for next time
	tempval |= (chk_trap_status() << 5);	
 3ae:	40 e2       	ldi	r20, 0x20	; 32
 3b0:	84 9f       	mul	r24, r20
 3b2:	c0 01       	movw	r24, r0
 3b4:	11 24       	eor	r1, r1
 3b6:	82 2b       	or	r24, r18
	return tempval;	//after setting appropriate bits this will be returned and sent in the TX packet
}	//end of fill TX bitfield
 3b8:	85 61       	ori	r24, 0x15	; 21
 3ba:	cf 91       	pop	r28
 3bc:	08 95       	ret

000003be <take_picture>:

	}	//end of read_PRX function


void take_picture(void){
	camera_busy = 1;	//set busy flag
 3be:	81 e0       	ldi	r24, 0x01	; 1
 3c0:	80 93 0f 01 	sts	0x010F, r24
	PORTB &= ~(0x02);	//clear PB1 which is the shutter release pin
 3c4:	29 98       	cbi	0x05, 1	; 5
	set_camera_delay(1000);	//set a 1 second delay before the mS timer will call back the 'camera_done' function
 3c6:	68 ee       	ldi	r22, 0xE8	; 232
 3c8:	73 e0       	ldi	r23, 0x03	; 3
 3ca:	80 e0       	ldi	r24, 0x00	; 0
 3cc:	90 e0       	ldi	r25, 0x00	; 0
 3ce:	0c 94 f6 02 	jmp	0x5ec	; 0x5ec <set_camera_delay>

000003d2 <read_PRX>:



//This will call the PRX receive function and return the LSByte
void read_PRX(void){
	get_RX_Data(datain);
 3d2:	8c e1       	ldi	r24, 0x1C	; 28
 3d4:	91 e0       	ldi	r25, 0x01	; 1
 3d6:	0e 94 3c 01 	call	0x278	; 0x278 <get_RX_Data>

	//this will be the check to see if the remote is sending command to set the trap and also the trap state machine is not currently active
	if((datain[0] & 0x80)&&(!trap_busy)){
 3da:	80 91 1c 01 	lds	r24, 0x011C
 3de:	87 ff       	sbrs	r24, 7
 3e0:	09 c0       	rjmp	.+18     	; 0x3f4 <read_PRX+0x22>
 3e2:	80 91 10 01 	lds	r24, 0x0110
 3e6:	81 11       	cpse	r24, r1
 3e8:	05 c0       	rjmp	.+10     	; 0x3f4 <read_PRX+0x22>
		trap_busy = 1;	//set busy flag
 3ea:	81 e0       	ldi	r24, 0x01	; 1
 3ec:	80 93 10 01 	sts	0x0110, r24
		set_trap();
 3f0:	0e 94 47 03 	call	0x68e	; 0x68e <set_trap>
	}//end of checking if the trap command is being sent
	if(datain[0] & 0x10){
 3f4:	80 91 1c 01 	lds	r24, 0x011C
 3f8:	84 fd       	sbrc	r24, 4
		take_picture();
 3fa:	0e 94 df 01 	call	0x3be	; 0x3be <take_picture>
		}
		//PWM lights based on signal from PRX. 
	if(datain[0] & 0x40){
 3fe:	80 91 1c 01 	lds	r24, 0x011C
 402:	86 ff       	sbrs	r24, 6
 404:	02 c0       	rjmp	.+4      	; 0x40a <read_PRX+0x38>
		PORTD |= 0x08;
 406:	5b 9a       	sbi	0x0b, 3	; 11
 408:	08 95       	ret
	}	else{
		PORTD &= ~(0x08);
 40a:	5b 98       	cbi	0x0b, 3	; 11
 40c:	08 95       	ret

0000040e <clear_trap_busy>:



//clearing the 'trap_busy' flag.  This will be called when the 'set trap' state machine has run its course.
void clear_trap_busy(void){
	trap_busy = 0;
 40e:	10 92 10 01 	sts	0x0110, r1
 412:	08 95       	ret

00000414 <camera_done>:




void camera_done(void){
PORTB |= 0x02;	//stop pulling shutter release
 414:	29 9a       	sbi	0x05, 1	; 5
set_camera_delay(0);	//sending zero here will stop callbacks(push them back until the end of time)
 416:	60 e0       	ldi	r22, 0x00	; 0
 418:	70 e0       	ldi	r23, 0x00	; 0
 41a:	cb 01       	movw	r24, r22
 41c:	0e 94 f6 02 	call	0x5ec	; 0x5ec <set_camera_delay>
camera_busy = 0;	
 420:	10 92 0f 01 	sts	0x010F, r1
 424:	08 95       	ret

00000426 <pre_set>:


/*State Machine Functions which will be cycled through based on calls from Timer0 rollover interrupt.  The flow is a bit weird but seems to me like the best way to do it.  Initially will go to pre-arm, this is pointed to by the Timer0 init function
*/

u8 pre_set (u8* wait_time){
 426:	fc 01       	movw	r30, r24
	OCR0A = 0;	//make sure timer is off
 428:	17 bc       	out	0x27, r1	; 39
	TCCR0B |= 0x05;	//setting prescaler bits which will enable clock
 42a:	95 b5       	in	r25, 0x25	; 37
 42c:	95 60       	ori	r25, 0x05	; 5
 42e:	95 bd       	out	0x25, r25	; 37
	PORTD |= 0x20;	//turn on servo
 430:	5d 9a       	sbi	0x0b, 5	; 11
	*wait_time = 0x03;	//this will be the number of 65mS period counter rollovers...3 corresponds to ~185mSeconds...need to scope the time for caps to charge.
 432:	83 e0       	ldi	r24, 0x03	; 3
 434:	80 83       	st	Z, r24
	state_runner = set;
 436:	8c e4       	ldi	r24, 0x4C	; 76
 438:	92 e0       	ldi	r25, 0x02	; 2
 43a:	90 93 1b 01 	sts	0x011B, r25
 43e:	80 93 1a 01 	sts	0x011A, r24
	return 0;	//will only return 1 at end of 'off' pointer
}
 442:	80 e0       	ldi	r24, 0x00	; 0
 444:	08 95       	ret

00000446 <pre_arm>:
	return 2;	//if seeing a 2 on the return can set a flag saying that we're set.
}


//pre-arm will get pointed to right after the timer is initialized, as this will get everything set up for arming the trap and waiting for the timer to be re-activated after it is pointed towards 'pre-set'.
u8 pre_arm (u8* wait_time){
 446:	fc 01       	movw	r30, r24
	OCR0A = 0;	//ensure we're off
 448:	17 bc       	out	0x27, r1	; 39
	TCCR0B |= 0x05;	//make sure clock is enabled
 44a:	95 b5       	in	r25, 0x25	; 37
 44c:	95 60       	ori	r25, 0x05	; 5
 44e:	95 bd       	out	0x25, r25	; 37
	PORTD |= 0x20;	//turn on servo
 450:	5d 9a       	sbi	0x0b, 5	; 11
	*wait_time = 0x08;		//this will be the number of 65mS period counter rollovers...8 corresponds to ~.5 seconds
 452:	88 e0       	ldi	r24, 0x08	; 8
 454:	80 83       	st	Z, r24
	state_runner = arm;	//point to arm where this will actually run the servo to the arm position.
 456:	83 e3       	ldi	r24, 0x33	; 51
 458:	92 e0       	ldi	r25, 0x02	; 2
 45a:	90 93 1b 01 	sts	0x011B, r25
 45e:	80 93 1a 01 	sts	0x011A, r24
	return 0;
}
 462:	80 e0       	ldi	r24, 0x00	; 0
 464:	08 95       	ret

00000466 <arm>:


//was hoping to disable timer in the name of saving power when the micro is sleeping.  Turns out that the micro gives a quick short pulse while turning off/on which is making noise on the servo.  Need to either 
//shut off servo before disabling/enabling pulser or just live with the timer drawing current while down.  
u8 arm (u8* wait_time){
	OCR0A = 0x05;	//Value to arm trap
 466:	25 e0       	ldi	r18, 0x05	; 5
 468:	27 bd       	out	0x27, r18	; 39
	*wait_time = 0x10;	//wait about 1 second to ensure that the servo has reached it's goal.
 46a:	20 e1       	ldi	r18, 0x10	; 16
 46c:	fc 01       	movw	r30, r24
 46e:	20 83       	st	Z, r18
	state_runner = off;	//point to off.
 470:	80 e4       	ldi	r24, 0x40	; 64
 472:	92 e0       	ldi	r25, 0x02	; 2
 474:	90 93 1b 01 	sts	0x011B, r25
 478:	80 93 1a 01 	sts	0x011A, r24
	return 0;
}
 47c:	80 e0       	ldi	r24, 0x00	; 0
 47e:	08 95       	ret

00000480 <off>:


u8 off (u8* wait_time){
	OCR0A = 0;
 480:	17 bc       	out	0x27, r1	; 39
	PORTD &= ~(0x20);	//turn off power to servo
 482:	5d 98       	cbi	0x0b, 5	; 11
	*wait_time = 0x01;	//make sure that the new overflow counter target is going to get reached next ISR. 
 484:	21 e0       	ldi	r18, 0x01	; 1
 486:	fc 01       	movw	r30, r24
 488:	20 83       	st	Z, r18
	TIMSK2 &= ~(0x01);	//disable Timer0 Overflow Interrupts
 48a:	e0 e7       	ldi	r30, 0x70	; 112
 48c:	f0 e0       	ldi	r31, 0x00	; 0
 48e:	80 81       	ld	r24, Z
 490:	8e 7f       	andi	r24, 0xFE	; 254
 492:	80 83       	st	Z, r24
	return 1;
}
 494:	81 e0       	ldi	r24, 0x01	; 1
 496:	08 95       	ret

00000498 <set>:
	return 0;	//will only return 1 at end of 'off' pointer
}


u8 set (u8* wait_time){
	OCR0A = 0x09;	//value to set trap
 498:	29 e0       	ldi	r18, 0x09	; 9
 49a:	27 bd       	out	0x27, r18	; 39
	*wait_time = 0x10;	//rollovers of 65mS clock...This is about 1 second
 49c:	20 e1       	ldi	r18, 0x10	; 16
 49e:	fc 01       	movw	r30, r24
 4a0:	20 83       	st	Z, r18
	state_runner = arm;	//skip over pre-arm, that's where we'll intially jump into this at power-up
 4a2:	83 e3       	ldi	r24, 0x33	; 51
 4a4:	92 e0       	ldi	r25, 0x02	; 2
 4a6:	90 93 1b 01 	sts	0x011B, r25
 4aa:	80 93 1a 01 	sts	0x011A, r24
	take_picture();	//trigger shutter release to snap a shot as the trap is setting
 4ae:	0e 94 df 01 	call	0x3be	; 0x3be <take_picture>
	return 2;	//if seeing a 2 on the return can set a flag saying that we're set.
}
 4b2:	82 e0       	ldi	r24, 0x02	; 2
 4b4:	08 95       	ret

000004b6 <__vector_7>:
static u8	fiftymsroll = 50;	//decremented every millisecond, when it reaches zero is a flag that 50mS have passed
static u8	fiftyms_flag = 0;	//flag to be set every 5 milliseconds.
static u8 trap_status = 0;		//This flag will be set to 1 after the trap is set and the state machine to set it has gone through all of its stages.

ISR(TIMER2_COMPA_vect) //Will use this ISR to manage mS timer and call functions that need to get ramped/amped every X mS 
{   
 4b6:	1f 92       	push	r1
 4b8:	0f 92       	push	r0
 4ba:	0f b6       	in	r0, 0x3f	; 63
 4bc:	0f 92       	push	r0
 4be:	11 24       	eor	r1, r1
 4c0:	2f 93       	push	r18
 4c2:	3f 93       	push	r19
 4c4:	4f 93       	push	r20
 4c6:	5f 93       	push	r21
 4c8:	6f 93       	push	r22
 4ca:	7f 93       	push	r23
 4cc:	8f 93       	push	r24
 4ce:	9f 93       	push	r25
 4d0:	af 93       	push	r26
 4d2:	bf 93       	push	r27
 4d4:	ef 93       	push	r30
 4d6:	ff 93       	push	r31

mSecond ++;
 4d8:	80 91 14 01 	lds	r24, 0x0114
 4dc:	90 91 15 01 	lds	r25, 0x0115
 4e0:	a0 91 16 01 	lds	r26, 0x0116
 4e4:	b0 91 17 01 	lds	r27, 0x0117
 4e8:	01 96       	adiw	r24, 0x01	; 1
 4ea:	a1 1d       	adc	r26, r1
 4ec:	b1 1d       	adc	r27, r1
 4ee:	80 93 14 01 	sts	0x0114, r24
 4f2:	90 93 15 01 	sts	0x0115, r25
 4f6:	a0 93 16 01 	sts	0x0116, r26
 4fa:	b0 93 17 01 	sts	0x0117, r27
fiftymsroll --;
 4fe:	20 91 09 01 	lds	r18, 0x0109
 502:	21 50       	subi	r18, 0x01	; 1
if (0 == fiftymsroll){
 504:	19 f0       	breq	.+6      	; 0x50c <__vector_7+0x56>

ISR(TIMER2_COMPA_vect) //Will use this ISR to manage mS timer and call functions that need to get ramped/amped every X mS 
{   

mSecond ++;
fiftymsroll --;
 506:	20 93 09 01 	sts	0x0109, r18
 50a:	06 c0       	rjmp	.+12     	; 0x518 <__vector_7+0x62>
if (0 == fiftymsroll){
	fiftymsroll = 50;
 50c:	22 e3       	ldi	r18, 0x32	; 50
 50e:	20 93 09 01 	sts	0x0109, r18
	fiftyms_flag = 1;	
 512:	21 e0       	ldi	r18, 0x01	; 1
 514:	20 93 13 01 	sts	0x0113, r18
}

if(mSecond >= camera_release){
 518:	40 91 0a 01 	lds	r20, 0x010A
 51c:	50 91 0b 01 	lds	r21, 0x010B
 520:	60 91 0c 01 	lds	r22, 0x010C
 524:	70 91 0d 01 	lds	r23, 0x010D
 528:	84 17       	cp	r24, r20
 52a:	95 07       	cpc	r25, r21
 52c:	a6 07       	cpc	r26, r22
 52e:	b7 07       	cpc	r27, r23
 530:	10 f0       	brcs	.+4      	; 0x536 <__vector_7+0x80>
	camera_done();	//if the mS timer has passed its target value, let the 'Trap_PTX' file know via timesup.
 532:	0e 94 0a 02 	call	0x414	; 0x414 <camera_done>
}

    if(fiftymsroll == 25){
 536:	80 91 09 01 	lds	r24, 0x0109
 53a:	89 31       	cpi	r24, 0x19	; 25
 53c:	11 f4       	brne	.+4      	; 0x542 <__vector_7+0x8c>
	make40K();  //start pulsing the ultrsaonic transmitter
 53e:	0e 94 53 03 	call	0x6a6	; 0x6a6 <make40K>
}
}	//end of mS rollover
 542:	ff 91       	pop	r31
 544:	ef 91       	pop	r30
 546:	bf 91       	pop	r27
 548:	af 91       	pop	r26
 54a:	9f 91       	pop	r25
 54c:	8f 91       	pop	r24
 54e:	7f 91       	pop	r23
 550:	6f 91       	pop	r22
 552:	5f 91       	pop	r21
 554:	4f 91       	pop	r20
 556:	3f 91       	pop	r19
 558:	2f 91       	pop	r18
 55a:	0f 90       	pop	r0
 55c:	0f be       	out	0x3f, r0	; 63
 55e:	0f 90       	pop	r0
 560:	1f 90       	pop	r1
 562:	18 95       	reti

00000564 <__vector_16>:



ISR(TIMER0_OVF_vect) //Timer0 will rollover about every 65mS when running, as this is the clock for generating low freq. pulses for hte servo.  Will use this rollover to increment a variable and compare it to a value set in the state machine
{
 564:	1f 92       	push	r1
 566:	0f 92       	push	r0
 568:	0f b6       	in	r0, 0x3f	; 63
 56a:	0f 92       	push	r0
 56c:	11 24       	eor	r1, r1
 56e:	2f 93       	push	r18
 570:	3f 93       	push	r19
 572:	4f 93       	push	r20
 574:	5f 93       	push	r21
 576:	6f 93       	push	r22
 578:	7f 93       	push	r23
 57a:	8f 93       	push	r24
 57c:	9f 93       	push	r25
 57e:	af 93       	push	r26
 580:	bf 93       	push	r27
 582:	ef 93       	push	r30
 584:	ff 93       	push	r31
	static u8 t0ovf = 0;	//initialize compare variable. This gets incremented every rollover and compared to a target value to advance the state machine.
	static u8 t0ovf_target =1;		//this is the target variable that gets set every rollover
	u8 tmp_returnvar = 0;	//state runner will return this variable.  When the state machine is done this will be set to 1.  need to implement checking of this at end of ISR.
	t0ovf ++;
 586:	80 91 11 01 	lds	r24, 0x0111
 58a:	8f 5f       	subi	r24, 0xFF	; 255
 58c:	80 93 11 01 	sts	0x0111, r24
	if (t0ovf == t0ovf_target){
 590:	90 91 08 01 	lds	r25, 0x0108
 594:	89 13       	cpse	r24, r25
 596:	10 c0       	rjmp	.+32     	; 0x5b8 <__vector_16+0x54>
		t0ovf = 0;
 598:	10 92 11 01 	sts	0x0111, r1
		tmp_returnvar = state_runner(&t0ovf_target);	//call 'state_runner' which is a function pointer that's pointed to the applicable state.  The state machine will set the next t0ovf_target value and point the function pointer to the correct stage.  Will return a flag 
 59c:	e0 91 1a 01 	lds	r30, 0x011A
 5a0:	f0 91 1b 01 	lds	r31, 0x011B
 5a4:	88 e0       	ldi	r24, 0x08	; 8
 5a6:	91 e0       	ldi	r25, 0x01	; 1
 5a8:	09 95       	icall
		if(tmp_returnvar == 1) {}	//state_runner will return a 1 when the servo is in the armed position and has been turned off.
			else if (tmp_returnvar == 2) {
 5aa:	82 30       	cpi	r24, 0x02	; 2
 5ac:	29 f4       	brne	.+10     	; 0x5b8 <__vector_16+0x54>
				clear_trap_busy();	//let the PTX file know that the state machine has run its course
 5ae:	0e 94 07 02 	call	0x40e	; 0x40e <clear_trap_busy>
				trap_status = 1;	//setting flag that will be checked by the PTX TX function
 5b2:	81 e0       	ldi	r24, 0x01	; 1
 5b4:	80 93 12 01 	sts	0x0112, r24
				}	
				
	}
}
 5b8:	ff 91       	pop	r31
 5ba:	ef 91       	pop	r30
 5bc:	bf 91       	pop	r27
 5be:	af 91       	pop	r26
 5c0:	9f 91       	pop	r25
 5c2:	8f 91       	pop	r24
 5c4:	7f 91       	pop	r23
 5c6:	6f 91       	pop	r22
 5c8:	5f 91       	pop	r21
 5ca:	4f 91       	pop	r20
 5cc:	3f 91       	pop	r19
 5ce:	2f 91       	pop	r18
 5d0:	0f 90       	pop	r0
 5d2:	0f be       	out	0x3f, r0	; 63
 5d4:	0f 90       	pop	r0
 5d6:	1f 90       	pop	r1
 5d8:	18 95       	reti

000005da <get_mS_cnt>:


//return current mS timer
u32 get_mS_cnt (void){
	return (mSecond);
 5da:	60 91 14 01 	lds	r22, 0x0114
 5de:	70 91 15 01 	lds	r23, 0x0115
 5e2:	80 91 16 01 	lds	r24, 0x0116
 5e6:	90 91 17 01 	lds	r25, 0x0117
}
 5ea:	08 95       	ret

000005ec <set_camera_delay>:



//when I want to take a picture will pull down the shutter release pin and then use this to set a delay.  When hte mS timer passes delay_time I'll call a callback function to release the shutter release and clare teh 'camera busy' flag.
void set_camera_delay(u32 delay_time){
 5ec:	0f 93       	push	r16
 5ee:	1f 93       	push	r17
	if(delay_time){
 5f0:	61 15       	cp	r22, r1
 5f2:	71 05       	cpc	r23, r1
 5f4:	81 05       	cpc	r24, r1
 5f6:	91 05       	cpc	r25, r1
 5f8:	79 f0       	breq	.+30     	; 0x618 <set_camera_delay+0x2c>
		camera_release = (mSecond + delay_time);
 5fa:	00 91 14 01 	lds	r16, 0x0114
 5fe:	10 91 15 01 	lds	r17, 0x0115
 602:	20 91 16 01 	lds	r18, 0x0116
 606:	30 91 17 01 	lds	r19, 0x0117
 60a:	dc 01       	movw	r26, r24
 60c:	cb 01       	movw	r24, r22
 60e:	80 0f       	add	r24, r16
 610:	91 1f       	adc	r25, r17
 612:	a2 1f       	adc	r26, r18
 614:	b3 1f       	adc	r27, r19
 616:	03 c0       	rjmp	.+6      	; 0x61e <set_camera_delay+0x32>
	}else{
		camera_release = 0xFFFFFFFF;
 618:	8f ef       	ldi	r24, 0xFF	; 255
 61a:	9f ef       	ldi	r25, 0xFF	; 255
 61c:	dc 01       	movw	r26, r24
 61e:	80 93 0a 01 	sts	0x010A, r24
 622:	90 93 0b 01 	sts	0x010B, r25
 626:	a0 93 0c 01 	sts	0x010C, r26
 62a:	b0 93 0d 01 	sts	0x010D, r27
	}
}
 62e:	1f 91       	pop	r17
 630:	0f 91       	pop	r16
 632:	08 95       	ret

00000634 <Timer0_init>:


/*Using Timer 0 output A to drive pulses into Servo.  Here's some early/initial config.  Will also want to have the ability to turn timer off to save battery when not drivng the servo.
with the 15.3Hz frequency I'm getting, the resoulution is ~256uS/timer unit.  Not a whole lot of range but it will get me the extremes I need for setting/initializing the servo*/
void Timer0_init(void){
	TCCR0A = 0x81;	//setting up OC0A and WGM00
 634:	81 e8       	ldi	r24, 0x81	; 129
 636:	84 bd       	out	0x24, r24	; 36
	TCCR0B = 0x05;	//setting /1024 prescaler which should be good for ~15Hz, perfect for servo
 638:	85 e0       	ldi	r24, 0x05	; 5
 63a:	85 bd       	out	0x25, r24	; 37
	OCR0A = 0x05;		//Arm Trap
 63c:	87 bd       	out	0x27, r24	; 39
	state_runner = pre_arm;	//initializing pointer to point at the pre-arm function.  This will turn on the servo's power and initialize the timer.
 63e:	83 e2       	ldi	r24, 0x23	; 35
 640:	92 e0       	ldi	r25, 0x02	; 2
 642:	90 93 1b 01 	sts	0x011B, r25
 646:	80 93 1a 01 	sts	0x011A, r24
	TIFR0 |= 0x01;	//write one to interrupt flag to clear it prior to enable.
 64a:	a8 9a       	sbi	0x15, 0	; 21
	TIMSK0 |= 0x01;	//enable interrupt on Timer0 overflow
 64c:	ee e6       	ldi	r30, 0x6E	; 110
 64e:	f0 e0       	ldi	r31, 0x00	; 0
 650:	80 81       	ld	r24, Z
 652:	81 60       	ori	r24, 0x01	; 1
 654:	80 83       	st	Z, r24
 656:	08 95       	ret

00000658 <Timer2_init>:


//millisecond timer implemented via compare ISR
void Timer2_init(void) {
//8-bit timer 2 for mS timer	
	OCR2A = 250;	//this is top.  Timer has 8M clock /32 prescaler(*250) = 1Khz
 658:	8a ef       	ldi	r24, 0xFA	; 250
 65a:	80 93 b3 00 	sts	0x00B3, r24
	TCCR2A = 0x42;	//This will change to 0x02 eventually, right now using COMA2 as output for testing
 65e:	82 e4       	ldi	r24, 0x42	; 66
 660:	80 93 b0 00 	sts	0x00B0, r24
	TCCR2B = 0x03;
 664:	83 e0       	ldi	r24, 0x03	; 3
 666:	80 93 b1 00 	sts	0x00B1, r24
	TIFR2 |= 0X02;	//CLEAR Interrupt flag prior to enabling interrupts (by writing a 1 to it weird huh?)
 66a:	b9 9a       	sbi	0x17, 1	; 23
	TIMSK2 |= 0X02;	//enable Timer2 Compare Interrupts
 66c:	e0 e7       	ldi	r30, 0x70	; 112
 66e:	f0 e0       	ldi	r31, 0x00	; 0
 670:	80 81       	ld	r24, Z
 672:	82 60       	ori	r24, 0x02	; 2
 674:	80 83       	st	Z, r24
 676:	08 95       	ret

00000678 <fifty_stat>:



//see if 50mS have rolled over and if so reset the roll.
u8	fifty_stat(void){
	if(fiftyms_flag){
 678:	80 91 13 01 	lds	r24, 0x0113
 67c:	88 23       	and	r24, r24
 67e:	19 f0       	breq	.+6      	; 0x686 <fifty_stat+0xe>
		fiftyms_flag = 0;
 680:	10 92 13 01 	sts	0x0113, r1
		return 1;
 684:	81 e0       	ldi	r24, 0x01	; 1
	}else{
		return 0;
	}
}
 686:	08 95       	ret

00000688 <chk_trap_status>:
//////////////////////////////////////////////////////////////end of state machine functions

//this is determined by the state machine and used as a flag in the bitfield being sent to the PRX
u8 chk_trap_status(void){
	return trap_status;
}
 688:	80 91 12 01 	lds	r24, 0x0112
 68c:	08 95       	ret

0000068e <set_trap>:

//When this is called it will re-initialize the Timer0 interrupt and point function pointer towards getting ready to set.
void set_trap (void){
	TIMSK2 |= 0x01;	//re-enable Timer0 Overflow Interrupts
 68e:	e0 e7       	ldi	r30, 0x70	; 112
 690:	f0 e0       	ldi	r31, 0x00	; 0
 692:	80 81       	ld	r24, Z
 694:	81 60       	ori	r24, 0x01	; 1
 696:	80 83       	st	Z, r24
	state_runner = pre_set;	//point to preparing to arm
 698:	83 e1       	ldi	r24, 0x13	; 19
 69a:	92 e0       	ldi	r25, 0x02	; 2
 69c:	90 93 1b 01 	sts	0x011B, r25
 6a0:	80 93 1a 01 	sts	0x011A, r24
 6a4:	08 95       	ret

000006a6 <make40K>:
} //end of ISR



void make40K(void){
    set_tp1
 6a6:	43 9a       	sbi	0x08, 3	; 8
    TCNT1 = 0;  //start fresh
 6a8:	10 92 85 00 	sts	0x0085, r1
 6ac:	10 92 84 00 	sts	0x0084, r1
    TIFR1 |= (1<<OCR1A);    //clear interrupt flag for Timer1 Compare A
 6b0:	e8 e8       	ldi	r30, 0x88	; 136
 6b2:	f0 e0       	ldi	r31, 0x00	; 0
 6b4:	40 81       	ld	r20, Z
 6b6:	51 81       	ldd	r21, Z+1	; 0x01
 6b8:	26 b3       	in	r18, 0x16	; 22
 6ba:	81 e0       	ldi	r24, 0x01	; 1
 6bc:	90 e0       	ldi	r25, 0x00	; 0
 6be:	01 c0       	rjmp	.+2      	; 0x6c2 <make40K+0x1c>
 6c0:	88 0f       	add	r24, r24
 6c2:	4a 95       	dec	r20
 6c4:	ea f7       	brpl	.-6      	; 0x6c0 <make40K+0x1a>
 6c6:	82 2b       	or	r24, r18
 6c8:	86 bb       	out	0x16, r24	; 22
    TIMSK1 |= (1<<OCIE1A);  //enable interrupt
 6ca:	af e6       	ldi	r26, 0x6F	; 111
 6cc:	b0 e0       	ldi	r27, 0x00	; 0
 6ce:	8c 91       	ld	r24, X
 6d0:	82 60       	ori	r24, 0x02	; 2
 6d2:	8c 93       	st	X, r24
    OCR1A = 100;    //with no prescaler and a compare match value of 100, this should give me a CTC of 40Khz
 6d4:	84 e6       	ldi	r24, 0x64	; 100
 6d6:	90 e0       	ldi	r25, 0x00	; 0
 6d8:	91 83       	std	Z+1, r25	; 0x01
 6da:	80 83       	st	Z, r24
    TCCR1A = (1<< COM1B0);  //set up OC1B to toggle on CTC match
 6dc:	80 e1       	ldi	r24, 0x10	; 16
 6de:	80 93 80 00 	sts	0x0080, r24
    TCCR1B =   (1 << WGM12) | (1 << CS10);  //set CTC with OCR1A as compare value and a prescaler of 1
 6e2:	89 e0       	ldi	r24, 0x09	; 9
 6e4:	80 93 81 00 	sts	0x0081, r24
      led2_on
 6e8:	41 9a       	sbi	0x08, 1	; 8
 6ea:	08 95       	ret

000006ec <wait4Rebound>:
 
 
 
 void wait4Rebound(void){
    //TODO: set up T1 for normal mode, enable interrupt on falling edge of INT0
     TCNT1 = 0; //reset counter to start fresh
 6ec:	10 92 85 00 	sts	0x0085, r1
 6f0:	10 92 84 00 	sts	0x0084, r1
     OCR1A = 255;   //8uS period counting to 255 = 2.04mS
 6f4:	8f ef       	ldi	r24, 0xFF	; 255
 6f6:	90 e0       	ldi	r25, 0x00	; 0
 6f8:	90 93 89 00 	sts	0x0089, r25
 6fc:	80 93 88 00 	sts	0x0088, r24
     TCCR1B = (1 << CS10) | (1<< CS11); //give me a /64 prescaler
 700:	83 e0       	ldi	r24, 0x03	; 3
 702:	80 93 81 00 	sts	0x0081, r24
 706:	08 95       	ret

00000708 <__vector_11>:
 708:	1f 92       	push	r1
 70a:	0f 92       	push	r0
 70c:	0f b6       	in	r0, 0x3f	; 63
 70e:	0f 92       	push	r0
 710:	11 24       	eor	r1, r1
 712:	2f 93       	push	r18
 714:	3f 93       	push	r19
 716:	4f 93       	push	r20
 718:	5f 93       	push	r21
 71a:	6f 93       	push	r22
 71c:	7f 93       	push	r23
 71e:	8f 93       	push	r24
 720:	9f 93       	push	r25
 722:	af 93       	push	r26
 724:	bf 93       	push	r27
 726:	ef 93       	push	r30
 728:	ff 93       	push	r31
 72a:	80 91 19 01 	lds	r24, 0x0119
 72e:	81 11       	cpse	r24, r1
 730:	14 c0       	rjmp	.+40     	; 0x75a <__vector_11+0x52>
 732:	80 91 18 01 	lds	r24, 0x0118
 736:	8f 5f       	subi	r24, 0xFF	; 255
 738:	80 31       	cpi	r24, 0x10	; 16
 73a:	18 f4       	brcc	.+6      	; 0x742 <__vector_11+0x3a>
 73c:	80 93 18 01 	sts	0x0118, r24
 740:	11 c0       	rjmp	.+34     	; 0x764 <__vector_11+0x5c>
 742:	10 92 18 01 	sts	0x0118, r1
 746:	10 92 80 00 	sts	0x0080, r1
 74a:	10 92 81 00 	sts	0x0081, r1
 74e:	81 e0       	ldi	r24, 0x01	; 1
 750:	80 93 19 01 	sts	0x0119, r24
 754:	0e 94 76 03 	call	0x6ec	; 0x6ec <wait4Rebound>
 758:	05 c0       	rjmp	.+10     	; 0x764 <__vector_11+0x5c>
 75a:	43 98       	cbi	0x08, 3	; 8
 75c:	10 92 81 00 	sts	0x0081, r1
 760:	10 92 19 01 	sts	0x0119, r1
 764:	ff 91       	pop	r31
 766:	ef 91       	pop	r30
 768:	bf 91       	pop	r27
 76a:	af 91       	pop	r26
 76c:	9f 91       	pop	r25
 76e:	8f 91       	pop	r24
 770:	7f 91       	pop	r23
 772:	6f 91       	pop	r22
 774:	5f 91       	pop	r21
 776:	4f 91       	pop	r20
 778:	3f 91       	pop	r19
 77a:	2f 91       	pop	r18
 77c:	0f 90       	pop	r0
 77e:	0f be       	out	0x3f, r0	; 63
 780:	0f 90       	pop	r0
 782:	1f 90       	pop	r1
 784:	18 95       	reti

00000786 <main>:


int main(void)
{
	
DDRD |= 0xFA;	//Chip Select Not, TXData UART, Timer0A outputs, servo power enable, IR input on PD2.  Power_on output on PD4.  Light control on PD3
 786:	8a b1       	in	r24, 0x0a	; 10
 788:	8a 6f       	ori	r24, 0xFA	; 250
 78a:	8a b9       	out	0x0a, r24	; 10
PORTD |= 0x10;	//Setting PortD4 to keep the power turned on.
 78c:	5c 9a       	sbi	0x0b, 4	; 11
Timer0_init();	//initialize Timer0 for Servo drive
 78e:	0e 94 1a 03 	call	0x634	; 0x634 <Timer0_init>
Timer2_init();	//using this for mS timer/50mS rollover
 792:	0e 94 2c 03 	call	0x658	; 0x658 <Timer2_init>
ADC_Init();
 796:	0e 94 53 00 	call	0xa6	; 0xa6 <ADC_Init>
DDRB = 0x2F;		//All of portB = outputs with exception of PB6-7 (XTAL), and PB4 (MISO).
 79a:	8f e2       	ldi	r24, 0x2F	; 47
 79c:	84 b9       	out	0x04, r24	; 4
/*PB0 = Chip Enable, PB1 = LED Out for switcher, PB2 = LED_PWM (also is SS, not used here but can't be left floating input), PB3 = MOSI, PB4 = MISO, PB5 = SCK, PB6-7 = oscillator*/
//This rev board has an external pullup, want to try that experimentally for now.  PORTB |= 0x02;	//setting pullup on PB1 which is the shutter release.
DDRC |= 0xFF;	//PC0 = OnBoard LEDs, PC3 = TP1
 79e:	87 b1       	in	r24, 0x07	; 7
 7a0:	8f ef       	ldi	r24, 0xFF	; 255
 7a2:	87 b9       	out	0x07, r24	; 7
PORTC = 0;
 7a4:	18 b8       	out	0x08, r1	; 8
//TODO: following line is leftover from PIR, 
EICRA = 0x01;	//configure INT0 to trigger on any logical change, the interrupt will be unmasked in Trap_PTX.c when it's needed.
 7a6:	81 e0       	ldi	r24, 0x01	; 1
 7a8:	80 93 69 00 	sts	0x0069, r24
sei();	//enable globals
 7ac:	78 94       	sei


//initialize SPI on AT328
SPCR = (1<<SPE)|(1<<MSTR);	
 7ae:	80 e5       	ldi	r24, 0x50	; 80
 7b0:	8c bd       	out	0x2c, r24	; 44

#ifdef PRX
enable_PRX();
#endif

initialize_NRF();
 7b2:	0e 94 9f 01 	call	0x33e	; 0x33e <initialize_NRF>
	
	sendPayLoad(W_TX_PAYLOAD, dataout, 2);
	}	//end of where to go if we've detected a 50mS rollover via fifty_stat

		if(check_Flag(RX_DR)){		//did I detect an awk-pack?
			led1_tog;		//here just want to see if I can see that I've received data and understand the mechanics of resetting the flag.
 7b6:	c4 e0       	ldi	r28, 0x04	; 4
initialize_NRF();

    while(1)
 {   
	
	if(fifty_stat()){
 7b8:	0e 94 3c 03 	call	0x678	; 0x678 <fifty_stat>
 7bc:	88 23       	and	r24, r24
 7be:	51 f0       	breq	.+20     	; 0x7d4 <main+0x4e>
		
		dataout[0] = fill_TX_bitfield();		//function to populate bitfield after scanning appropriate stuffs.
 7c0:	0e 94 cb 01 	call	0x396	; 0x396 <fill_TX_bitfield>
 7c4:	80 93 00 01 	sts	0x0100, r24
		
	
	
	sendPayLoad(W_TX_PAYLOAD, dataout, 2);
 7c8:	42 e0       	ldi	r20, 0x02	; 2
 7ca:	60 e0       	ldi	r22, 0x00	; 0
 7cc:	71 e0       	ldi	r23, 0x01	; 1
 7ce:	80 ea       	ldi	r24, 0xA0	; 160
 7d0:	0e 94 6c 01 	call	0x2d8	; 0x2d8 <sendPayLoad>
	}	//end of where to go if we've detected a 50mS rollover via fifty_stat

		if(check_Flag(RX_DR)){		//did I detect an awk-pack?
 7d4:	80 e4       	ldi	r24, 0x40	; 64
 7d6:	0e 94 ff 00 	call	0x1fe	; 0x1fe <check_Flag>
 7da:	88 23       	and	r24, r24
 7dc:	29 f0       	breq	.+10     	; 0x7e8 <main+0x62>
			led1_tog;		//here just want to see if I can see that I've received data and understand the mechanics of resetting the flag.
 7de:	88 b1       	in	r24, 0x08	; 8
 7e0:	8c 27       	eor	r24, r28
 7e2:	88 b9       	out	0x08, r24	; 8
			read_PRX();			
 7e4:	0e 94 e9 01 	call	0x3d2	; 0x3d2 <read_PRX>
		}	//end of what to do if an AWK-PAC
		


	if(check_Flag(MAX_RT)){	//this is saying that max retries have been sent out without a successful response.  All of this might be a bit excessive.
 7e8:	80 e1       	ldi	r24, 0x10	; 16
 7ea:	0e 94 ff 00 	call	0x1fe	; 0x1fe <check_Flag>
 7ee:	88 23       	and	r24, r24
 7f0:	19 f3       	breq	.-58     	; 0x7b8 <main+0x32>
		flushTx();	//clear transmitter FIFO
 7f2:	0e 94 8b 00 	call	0x116	; 0x116 <flushTx>
		flushRx();
 7f6:	0e 94 8e 00 	call	0x11c	; 0x11c <flushRx>
		clear_Flag(ALL_FLAG);
 7fa:	80 e7       	ldi	r24, 0x70	; 112
 7fc:	0e 94 09 01 	call	0x212	; 0x212 <clear_Flag>
 800:	db cf       	rjmp	.-74     	; 0x7b8 <main+0x32>

00000802 <_exit>:
 802:	f8 94       	cli

00000804 <__stop_program>:
 804:	ff cf       	rjmp	.-2      	; 0x804 <__stop_program>
